package main

import (
	"context"
	"embed"
	"net/http"
	"os"
	"os/signal"
	"time"

	"github.com/joho/godotenv"
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"go.uber.org/zap"
	"oneaccord.cc/pkg/migrator"

	"oneaccord.cc/<PROJECT_NAME>/config"
	"oneaccord.cc/<PROJECT_NAME>/internal/database"
	"oneaccord.cc/<PROJECT_NAME>/internal/routes/v1"
	"oneaccord.cc/<PROJECT_NAME>/internal/utils/apperror"
	"oneaccord.cc/<PROJECT_NAME>/internal/utils/redisclient"
)

// we embed migrations folder to the binary using go build in embed

//go:embed migrations/*.sql
var migrationsFiles embed.FS

func init() {
	zap.ReplaceGlobals(zap.Must(zap.NewProduction()))
	err := godotenv.Load()
	if err != nil {
		zap.L().Info("No .env file. Checking runtime...")
	}
	config.InitConfig()
	redisclient.RedisConnect()

	// Migrate Database at the start of the application
	if err := migrator.StartMigrate(context.Background(), config.Env.PostgresqlUrl, migrationsFiles); err != nil {
		zap.L().Fatal(err.Error())
	}
}

func main() {
	dbpool, err := db.OpenDB()
	if err != nil {
		zap.L().Fatal(err.Error())
	}
	defer dbpool.Close()
	e := echo.New()
	e.HideBanner = true
	e.HTTPErrorHandler = apperror.CustomErrorHandler

	e.Pre(middleware.RemoveTrailingSlash())
	e.Use(middleware.RequestLoggerWithConfig(middleware.RequestLoggerConfig{
		LogURI:    true,
		LogStatus: true,
		LogMethod: true,
		LogValuesFunc: func(c echo.Context, v middleware.RequestLoggerValues) error {
			zap.L().Info("request",
				zap.String("URI", v.URI),
				zap.String("time", v.StartTime.String()),
				zap.Int("status", v.Status),
				zap.String("Method", v.Method),
			)
			return nil
		},
	}))
	e.Use(middleware.Recover())
	e.Use(middleware.RequestID())
	e.Use(middleware.Secure())
	e.Use(middleware.TimeoutWithConfig(middleware.TimeoutConfig{
		Timeout: 10 * time.Second,
	}))

	// Health Check
	e.GET("/", func(c echo.Context) error {
		return c.JSON(200, "Up and Running")
	})

	// Routes
	v1.Load(e.Group("/v1"))

	e.RouteNotFound("/*", func(c echo.Context) error {
		return c.JSON(http.StatusNotFound, "Route Not Found")
	})

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
	defer stop()
	// Start server
	go func() {
		if err := e.Start(":" + config.Env.Port); err != nil && err != http.ErrServerClosed {
			e.Logger.Fatal("shutting down the server")
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server with a timeout of 10 seconds.
	<-ctx.Done()
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := e.Shutdown(ctx); err != nil {
		e.Logger.Fatal(err)
	}
}
